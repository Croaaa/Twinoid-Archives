<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>C++, héritage, pointeurs et unions</title>
    <link href="../../../../gfx/game/Twinoid.ico" rel="icon" type="image/gif"/>
    <link href="../../../../css/twinoid_layout.css" rel="stylesheet" type="text/css"/>
    <link href="../../../../css/twinoid_bar.css" rel="stylesheet" type="text/css"/>
    <link href="../../../../css/custom.css" rel="stylesheet" type="text/css"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script>
        $(document).ready(function() {
            $('.tid_niceHiddenNotice').click(function() {
                $(this).next('.tid_post').slideDown(500);
                $(this).slideUp(250);
            });
        });
    </script>
</head>
<body>
    <div id="contentBg">
        <div class="tid_forum_init" id="tid_forum">
            <div id="tid_forum_all"></div>
            <table class="tid_forumLayout">
                <tbody>
                    <tr>
                        <td id="tid_forum_right">
                            <div class="tid_containerWrapper">
                                <div class="tid_forumThread">
                                    <div class="tid_mainBar">
                                        <div class="tid_stack tid_bg4">
											<a class="tid_bg4" href="../../../Index.html" tid_href="left:">
												<img src="../../../../gfx/design/flag_FR.svg" style="width: 20px; height: 15px; vertical-align: middle;">
												Accueil
											</a>
                                            <a class="tid_bg4" href="../../Index.html" tid_href="left:">Twinoid</a>
                                            <a class="tid_bg4" href="../Index.html" tid_href="left:">Développement</a>
                                            <span class="tid_title">C++, héritage, pointeurs et unions</span>
                                        </div>
                                        
                                    </div>
                                    <div class="tid_clear tid_threadStart"></div>
                                    <div class="tid_post tid_ tid_read" id="tid_forumPost_0">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="Spirou003" style="background-color: rgb(84,82,204); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 20 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_26161 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/26161/1" tid_id="26161">Spirou003</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p>Bonsoir,</p><p>J'ai trouvé une méthode il y a un moment qui permet d'éviter l'utilisation de static_cast (par exemple) lorsqu'on veut changer le type de pointeur, en sachant d'avance qu'on peut le faire. Voici la situation:<br><cite>class A<br>{<br>...<br>};<br><br>class B : public A<br>{<br>...<br>};<br><br>union C<br>{<br>A * a;<br>B * b;<br>};<br><br>A * a;<br>...<br>// on sait que a pointe sur B<br>C c;<br>c.a = a;<br>B * b = c.b;<br></cite></p><p>À priori c'est correct de faire ça, et je n'ai jamais trouvé de bug en le faisant, mais je me demandais: est-ce vraiment fiable comme technique? N'y a-t-il pas un risque de faire crasher le programme dans certaines situations?</p><p>Merci!</p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div><div class="tid_post tid_ tid_read" id="tid_forumPost_1">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="ayalti" style="background-color: rgb(204,171,82); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 20 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_36044 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/36044/1" tid_id="36044">ayalti</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p>Ben ce n'est qu'un reinterpret_cast hein.</p><p>Si tu es sûr que ton a est en réalité un B, ça marchera. Mais ni le compilateur (comme dans un static_cast - ceci dit, là, ça ne servirait à rien), ni le runtime (en regardant l'information de type dynamique qui est planquée dans les objets) ne le vérifieront</p><p>Dans le static_cast, le compilateur vérifie au moins que c'est possible que ce soit compatible (ce qui serait le cas dans ton exemple, puisque B hérite de A. Même s'il n'y a aucune garantie que ton A est un B : tous les A ne sont pas des B, et il n'y a que dynamiquement qu'on peut le savoir).</p><p>Ta méthode, par exemple, permet aussi de faire ça</p><pre>class A {
 ...
};

class B {
 ... // sans aucun rapport avec le ... de A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// même pas forcément la même taille
};
union C {
 A *a;
 B *b;
}
etc.
</pre><p>Et tu vas, comme ça, caster sans problème un A* en B*, alors qu'il n'y a pas le moindre rapport avec le schmilblick.</p><p>Il va sans dire que si A et B sont comme ceci</p><pre>class A {
public: 
 int x;
};
class B {
public:
 char *txt;
};
union C{
 A* a;
 B* b;
};

int main(){
 A*a=new A();
 C c;
 C.a=a;
 B* b=c.b;
 printf("%s\n", b-&gt;txt);
}
</pre><p>Tu vas au devant de graves problèmes.</p><p>(Ce que tu écris là, n'est de toutes façons qu'une façon compliquée de faire des reinterpret_cast, considérés comme, sauf exception, à ne pas faire. Ou des casts C classiques, tant que ça reste pour des pointeurs :</p><pre>class A ...
class B...

int main(){
 A* a=new A();
 B*b = (B *)a;
}</pre><p>fait la même chose (c'est à dire un beau segfault avec mon code)</p><p>Ce n'est que dire au compilateur : je me fiche pas mal de ce qu'il y a à cet emplacement mémoire là, moi je vais le lire comme si c'était un B.<br>Pour faire une analogie, c'est comme renommer un .png en .doc, et dire à Office "si, si, c'est un .doc, je te jure, ouvre le".<br>Bon, si c'était effectivement un .doc planqué dans un .png, ben ça va marcher. Mais sinon...</p><br><p>(En plus, les "union" ce n'est que le mécanisme de C pour faire ce qu'on fait en C++ avec des héritages. C'est un peu bizarre de les utiliser pour forcer des héritages...)</p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div><div class="tid_post tid_ tid_read" id="tid_forumPost_2">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="Spirou003" style="background-color: rgb(84,82,204); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 20 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_26161 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/26161/1" tid_id="26161">Spirou003</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p>Merci d'avoir répondu aussi vite! <img src="../../../../gfx/square/eek.png" alt="8O" class="tid_ico"><br><span class="tid_preCite"><span class="tid_user tid_user_36044 tid_userBg tid_userUnknown tid_parsed" tid_bg="1" tid_id="36044">ayalti</span></span><cite>Ben ce n'est qu'un reinterpret_cast hein</cite><br>C'est aussi simple que ça? Il me semblait avoir lu que le reinterpret_cast faisait des vérification à l'exécution (ce qui le rendrait, j'imagine, moins rapide que ma méthode).</p><p><span class="tid_preCite"><span class="tid_user tid_user_36044 tid_userBg tid_userUnknown tid_parsed" tid_bg="1" tid_id="36044">ayalti</span></span><cite>Si tu es sûr que ton a est en réalité un B, ça marchera. Mais ni le compilateur (<strong>comme dans un static_cast - ceci dit, là, ça ne servirait à rien</strong>), ni le runtime (en regardant l'information de type dynamique qui est planquée dans les objets) ne le vérifieront</cite><br>J'ai mis static_cast sans réfléchir, c'est le premier qui m'est venu ^^. N'étant pas fan de ces opérateurs, je ne fais gaffe à leur fonctionnement (dans les grandes lignes) que si je n'ai "pas le choix" d'en utiliser (par exemple lorsque ça alourdit le code de faire sans l'utiliser, ni contourner).</p><p>Après, pour les assignations moisies, j'en ai fait (à peu près au même moment) pour essayer de voir (mais surtout deviner) les plantages / afichages que ça donnerait. C'est assez marrant je dois dire ^^</p><p><span class="tid_preCite"><span class="tid_user tid_user_36044 tid_userBg tid_userUnknown tid_parsed" tid_bg="1" tid_id="36044">ayalti</span></span><cite>En plus, les "union" ce n'est que le mécanisme de C pour faire ce qu'on fait en C++ avec des héritages. C'est un peu bizarre de les utiliser pour forcer des héritages...</cite><br>La seule fois où je m'en suis servi, c'était dans ce cas précis: changer le type d'un pointeur sans passer par les opérateurs existants qui, à priori, peuvent faire autre chose que bêtement copier le pointeur. Et c'était dans une situation d'héritage telle que je l'ai décrite dans mon premier post. Parmi une vingtaine de classes fille, une d'elles nécessitait un traîtement dont aucune autre n'avait besoin. Et ce traîtement passait par l'appel d'une méthode que seule cette classe possédait.</p><p><img src="../../../../gfx/square/smile.png" alt=":)" class="tid_ico"></p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div><div class="tid_post tid_ tid_read" id="tid_forumPost_3">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="ayalti" style="background-color: rgb(204,171,82); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 20 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_36044 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/36044/1" tid_id="36044">ayalti</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p>reinterpret_cast ne fait aucune conversion. Il ne fait rien. Rien du tout.</p><p>Quand le compilateur voit un reinterpret_cast, il ne génère strictement aucun code pour le faire.</p><p>Tout ce que le compilateur fait, c'est qu'avec un reinterpret_cast, il va accepter de compiler quelque chose qu'il n'aurait pas compilé sinon.</p><p>Par exemple, donc</p><pre>class A ;
class B ;
A * a ;
B * b ;
b=a;
</pre><p>ne compilera pas (le compilateur refusera de compiler, parce que un A n'est pas forcément un B.<br>Mais s'il avait compilé, tout ce qu'il aurait fait, c'est copier les 4 (en général) octets qui constituent le pointeur (l'adresse) rangé dans la variable a vers la variable b (ce qu'il fait quand il voit un = entre deux pointeurs du même type).</p><p>Tout ce que fait reinterpret_cast, c'est dire au compilateur "si, si, je te jure tu peux y aller, c'est le même type, même si on dirait pas comme ça".<br>Donc,</p><pre>class A ;
class B ;
A * a ;
B * b ;
b=reinterpret_cast&lt;B*&gt;(a);</pre><p>est exactement le même code que le précédent. Au détail près que celui là compilera, alors que l'autre le compilateur refusera de le compiler (mais il y a une bonne raison pour laquelle il refusera de le compiler : parce que c'est n'importe quoi ; ça sert à rien d'utiliser des types pour se protéger des erreurs, si c'est pour court-circuiter la protection^^)</p><p>static_cast, en revanche, d'une lui veut savoir que c'est possible (même si pas sûr). Il n'acceptera pas de convertir n'importe quel pointeur en n'importe quel pointeur. <br>Il ne compilera pas</p><pre>class A ;
class B ;
A * a ;
B * b ;
b=static_cast&lt;B *&gt;(a);</pre><p>parce qu'il n'a aucune raison de penser que c'est possible.<br>Mais il compilera</p><pre>class A ;
class B : public A ;
A * a ;
B * b ;
b=static_cast&lt;B*&gt;(a);</pre><p>parce que, si ça se trouve, c'est bon. Mais comme le dit le mot clé "static", c'est que en fonction de ce qu'il peut savoir à la compilation (static = décidé à la compilation ; dynamic = décidé à l'exécution).<br>Donc il ne peut pas réellement savoir que a est en réalité un B. Il ne peut que se dire que en tous cas, parfois, les A sont des B, et donc qu'il doit compiler ça (c'est une erreur à mon avis, mais c'est pas moi qui fais la norme C++. Si on décide de faire un langage soit disant fortement typé, on devrait refuser de compiler en l'absence de garantie que c'est légal. Sauf à la rigueur avec un reinterpret_cast, cad une demande explicite de l'utilisateur de se passer de la protection)</p><p>Et par ailleurs, static_cast peut générer du code de conversion. C'est pas juste une question de compiler ce que le compilateur n'aurait pas compilé sinon. Ça peut amener le compilateur à générer du code pour convertir un A* en B* (bon, pas là, puisqu'il n'y a pas de conversion à faire ; ce ne sont que des pointeurs, et il n'y a aucun opérateur de conversion programmé).</p><p>Par exemple static_cast&lt;float&gt;(x), si x est un int, génère du code pour convertir x en float (ce n'est pas qu'une interprétation : les octets en mémoire pour représenter 12 ne sont pas les mêmes que ceux pour représenter 12.0. Faut donc faire un calcul pour passer de l'un à l'autre)</p><br><p>dynamic_cast, lui, comme son nom l'indique, implique une décision dynamique, cad pas au moment de la compilation, mais, au cas par cas, à l'exécution.<br>Si à l'exécution, le type dynamique (les objets ont un champ caché "type dynamique", qui identifie leur type réel ; celui avec lequel ils ont été construits - enfin, ils ont ce champ quand, justement, le compilateur a détecté qu'il en aurait besoin, par exemple s'il y a des dynamic_cast dans le code, ou des méthodes virtuelles, etc) de a montre que a est bien un b en réalité, alors dynamic_cast&lt;B *&gt;(a) retournera un pointeur vers un b (en l'occurrence ce qu'aurait retourné reinterpret_cast).<br>Sinon il retournera NULL (ou lèvera une erreur).</p><br><p>Donc, en résumé : reinterpret_cast : jamais de conversion. static_cast, une conversion si nécessaire, écrite en dur dans le code généré (le programme convertira tout le temps, ou jamais). dynamic_cast : au cas par cas, en fonction de ce que contient réellement la variable, le transtypage est fait.</p><br><p>Je ne suis vraiment pas expert en C++ (j'ai programmé 2 ans en C, puis 10 ans en C++. Quand au bout de 10 ans j'ai constaté que j'étais toujours bien plus expert en C qu'en C++, j'en ai déduis que je ferais bien d'assumer et de revenir au C). Mais je sais que en général, quand on se pose les questions que tu te poses, c'est qu'on a déjà fait une erreur quelque part<br>(sauf si c'est pour triturer volontairement des exemples dans le but de comprendre. Là, je suis le premier à encourager mes étudiants à caster des double* en unsignesd char*)</p><p>Mais en tous cas, si ton seul problème est de forcer un transtypage, sans aucune vérification, et surtout sans aucun code de conversion, alors reinterpret_cast (comme son nom l'indique aussi d'ailleurs) est fait exactement pour ça.</p><p>(Limite, dans tes unions, du moins si le compilateur n'optimisait rien, tu génèrerait une affectation de plus qu'avec un reinterpret_cast)</p><p>J'ai pas listé le cast de C dans les possibilités : il veut dire plusieurs choses à la fois selon le contexte (y compris const_cast, qui est hors sujet ici). Des fois ça fait des conversions, des fois non. Des fois ça fait des vérifications, des fois non. <br>Mais en gros, en C, ton truc on l'écrirait juste (B*)a<br>(et là, ça ne ferait aucune vérification/conversion. Ce sont des pointeurs, on les réinterprète, c'est tout).</p><br><p>Là (outre me demander si tu n'aurais pas mieux fait de programmer en C, si c'est pour jongler avec des pointeurs), ce que le peu que tu dis m'inspire, c'est que, soit tu fais un truc vraiment crade (du genre tu supposes qu'il n'y a aucune erreur de programmation, et donc que quand certaines conditions sont remplies, tu es sûr que ton A est en réalité un B, donc tu transtypes pour pouvoir exécuter la bonne méthode).<br>Soit, tu es juste en train de reprogrammer la vérification dynamique générée automatiquement pour les méthodes virtuelles, tout ça dans le but d'éviter une vérification générée, que du coup tu vas faire toi-même à la main. Et ça reviendra exactement au même (sauf si donc, dans certains cas, tu peux t'abstraire de cette vérification, parce que le contexte de ton application te dit que normalement, tu peux, mais là on est de retour au premier choix).</p><br><br><p>En tous cas, quoi qu'il en soit, l'union n'a rien à faire là. Si tu veux faire un reinterpret_cast, fais un reinterpret_cast <img src="../../../../gfx/square/wink.png" alt=";)" class="tid_ico"></p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div><div class="tid_post tid_ tid_read" id="tid_forumPost_4">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="Spirou003" style="background-color: rgb(84,82,204); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 21 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_26161 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/26161/1" tid_id="26161">Spirou003</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p>Merci pour toutes ces explications <img src="../../../../gfx/square/smile.png" alt=":)" class="tid_ico"> Cette fois-ci je risque plus de les oublier.</p><p><cite>Mais en tous cas, si ton seul problème est de forcer un transtypage, sans aucune vérification, et surtout sans aucun code de conversion, alors reinterpret_cast (comme son nom l'indique aussi d'ailleurs) est fait exactement pour ça.</cite><br>Oui c'était juste ça mon problème ^^ Je pensais que reinterpret_cast faisait des tests parce que réinterprêter, interprêter, langage interprêté, etc. et surtout que je n'avais lu le contraire nulle part.</p><p><cite>Mais je sais que en général, quand on se pose les questions que tu te poses, c'est qu'on a déjà fait une erreur quelque part</cite><br>Je me posais la question parce que j'ai parfois joué avec des pointeurs de fonction et eu des plantages que j'ai pas compris (sur des transtypages notamment). Mais là je m'éloigne, d'autant plus que comme je le dis, j'ai juste joué avec, j'ai pas fait beaucoup d'efforts.<br>Après la seule fois que j'ai utilisé les unions pour transtyper, c'est pour ne pas avoir à modifier toutes mes classes pour éviter le transtypage. C'était la solution la plus simple, et elle ne m'empêchait pas d'atteindre les objectifs que je m'étais fixé, alors voilà.</p><p><cite>outre me demander si tu n'aurais pas mieux fait de programmer en C, si c'est pour jongler avec des pointeurs</cite><br>C'est pas la meilleure des raisons pour utiliser des pointeurs, mais je me dis ceci:<br>Pourquoi ajouter des références, qui font (à une grosse louche près) la même chose que les pointeurs, si c'est pour avoir des opérateurs d'allocations dynamiques en C++ qui renvoient un pointeur?<br><span class="tid_sideNote"><span class="tid_wspoil">Ok j'avoue, je trouve obj-&gt;fct() plus joli que obj.fct() <img src="../../../../gfx/square/happy.png" alt=":D" class="tid_ico"></span></span></p><p><cite>En tous cas, quoi qu'il en soit, l'union n'a rien à faire là. Si tu veux faire un reinterpret_cast, fais un reinterpret_cast</cite><br>À la base je voulais transtyper sans vérifier, mais ne savais pas que c'était un reinterpret_cast. Donc j'en voulais pas <img src="../../../../gfx/square/razz.png" alt=":P" class="tid_ico"> Mais à partir de maintenant on ne verra plus jamais dans mon code un transtypage avec union. Sauf par exemple si un jour j'ai besoin de montrer la représentation binaire d'un double à quelqu'un, puisque j'aimerais bien enseigner les mathématiques dans quelques années, et peut-être un peu d'informatique.</p><p><cite>Là (outre me demander si tu n'aurais pas mieux fait de programmer en C, si c'est pour jongler avec des pointeurs), ce que le peu que tu dis m'inspire, c'est que, soit tu fais un truc vraiment crade (du genre tu supposes qu'il n'y a aucune erreur de programmation, et donc que quand certaines conditions sont remplies, tu es sûr que ton A est en réalité un B, donc tu transtypes pour pouvoir exécuter la bonne méthode).<br>Soit, tu es juste en train de reprogrammer la vérification dynamique générée automatiquement pour les méthodes virtuelles, tout ça dans le but d'éviter une vérification générée, que du coup tu vas faire toi-même à la main. Et ça reviendra exactement au même (sauf si donc, dans certains cas, tu peux t'abstraire de cette vérification, parce que le contexte de ton application te dit que normalement, tu peux, mais là on est de retour au premier choix).</cite><br>J'ai essayé une fois la deuxième, mais ça a planté à un moment donné et j'ai pas trouvé pour quelle raison. Alors vu le travail que ça demandait pour faire quelque chose qui existe déjà (et en moins bien) j'ai abandonné.<br>Et pour ce qui m'a amené à poser la question, ça rentre dans le premier choix. J'ai du faire ce genre de chose parce que j'avais pas trouvé de solution qui me satisfasse plus que celle là. Le transtypage est une mauvaise chose, mais au moins le code était relativement simple. Enfin certainement plus simple que les solutions sans transtypage auxquelles j'avais pensé. Et puisque ça ne m'a pas empêché de faire ce que je voulais, je me suis accomodé d'en placer quelques uns.</p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div><div class="tid_post tid_ tid_read" id="tid_forumPost_5">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="ayalti" style="background-color: rgb(204,171,82); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 21 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_36044 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/36044/1" tid_id="36044">ayalti</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p>J'ai repensé à ton truc, et il y a un exemple bête pour te montrer à quel point c'est dangereux :</p><p>Déjà, si tu fais</p><pre>class A {
public: 
 int a;
};
class B : public A {
public:
 int b;
};</pre><p>Ton "B" va utiliser 8 octets (4 pour a, 4 pour b) et "A" va utiliser 4 octets (pour a).<br>Si tu sais exactement ce que tu fais, tu peux être tenté dire "pas de problème, tant que j'accède que au champ "a" des A, et que je n'accède aux champs "b" que quand je sais, pour je ne sais quelle raison que j'ai vraiment affaire à un B, tout ira bien".</p><p>Sauf que pour ça, il faut être sûr que le champ "a" sera rangé au début de la mémoire pour les B. Que dans B il ne s'amuse pas à inverser l'ordre des champs.</p><p>Bon, je doute qu'aucun compilo ne fasse ça, parce que ce serait chiant. J'ai testé g++ ne le fait pas. Mais je ne suis pas assez calé en C++ pour savoir si la norme te garantit qqc sur l'ordre des champs dans la structure. Si c'est pas le cas, ton code ne marche que par miracle, par les hasard des implémentations des compilateurs.</p><p>Mais il y a au moins un cas où je suis sûr que tu es marron !:</p><pre>class A {
public :
 int a;
};

class B : public A {
public:
 virtual void f();
};
</pre><p>Là, dans une instance de "B" l'attribut a se trouvera 4 octet après le début, alors que dans une instance de "A" il se trouvera au tout début. Parce que pour B il aura stocké avant un pointeur vers la classe dynamique, ce qu'il n'aura pas eu besoin de faire pour A.</p><p>On peut le vérifier facilement :</p><pre>A* a=new A();
 B* b=new B();
 a-&gt;a=0x0a0a0a0a;
 b-&gt;a=0x0a0a0a0a;

 printf("A : ");
 for(int i=0; i&lt;4; i++) printf("%02x ", ((unsigned char *)a)[i]);
 printf("\nB : ");
 for(int i=0; i&lt;8; i++) printf("%02x ", ((unsigned char *)b)[i]);
 printf("\n");
</pre><p>Réponse :</p><pre>A : 0a 0a 0a 0a 
B : 28 89 04 08 0a 0a 0a 0a </pre><p>Tu vois que les 0A0A0A0A ne sont pas placés au même endroit en mémoire suivant qu'on parle d'un A ou d'un B. (le 28890408 c'est le pointeur de classe dynamique)<br>Donc si tu fais un reinterpret_cast (ou un cast C classique sur les pointeurs, ou ton machin avec les union, ça fera pile pareil, et c'est ce que tu veux, puisque tu ne veux aucun calcul), il va complètement se mélanger les pinceaux : il va interpréter le contenu de la mémoire de a comme si c'était un B. Donc va prendre les 0a0a0a0a pour un pointeur de classe dynamique, et chercher après (les octets que j'ai pas affichés, vu qu'ils ne sont pas alloués) le contenu du champ a, ce qui va faire un beau segfault<br>Par exemple :</p><pre> printf("a.a=%08x\n", a-&gt;a);
 printf("b.a=%08x\n", b-&gt;a);</pre><p>Donne bien sûr</p><pre>a.a=0a0a0a0a
b.a=0a0a0a0a</pre><p>Mais</p><pre> printf("b.a'=%08x\n", reinterpret_cast&lt;A*&gt;(b)-&gt;a);
 printf("a.a'=%08x\n", reinterpret_cast&lt;B*&gt;(a)-&gt;a);</pre><p>Donne :</p><pre>b.a'=08048928
a.a'=00000000</pre><p>(Alors que pourtant b est bien un A, a bien un champ a, qui vaut 0x0a0a0a0a)<br>Pourquoi : parce que le 0x08048928 a été <strong>interprété</strong> à tort comme les 4 premiers octets d'un "A", cad comme son champ "a".<br>La deuxième réponse, 00000000, c'est parce qu'il fait l'inverse : il va chercher les octets 4,5,6,7 parce qu'il croit que c'est là qu'est "a". Pas de bol, c'est pas là.</p><p>Si tu avais fait un static_cast à la place du reinterpret_cast, au moins, ça, ça aurait marché. Il aurait bien répondu 0x0a0a0a0a à chaque fois ; parce que le compilateur aurait su aller chercher au bon index à chaque fois, en fonction du type concerné. Et ça ne t'aurait strictement rien coûté en terme de "conversion" : ça ne fait que changer un "0" en "4" dans une instruction de déréfencement indexé.</p><p>J'en arrive à la partie qui te concerne plus, parce que jusque là, je n'ai parlé que de ce qui se passe quand on essaye de caster des A en B et des vrai B en A. <br>Mais même si maintenant tu remplace la création de "a" par</p><pre>A *a=new B()</pre><p>Tu constates que ça ne change strictement rien au problème. Le reinterpret_cast (ou le coup des unions), va te donner un "B" qui ne contient pas les champs aux bons endroits. Alors que pourtout, c'est vraiment un B.</p><pre>printf("%x\n", reinterpret_cast&lt;B *&gt;(a)-&gt;a);</pre><p>va afficher 0 (parce que j'ai du bol et que la mémoire est allouée pour une autre variable de mon code ; sinon ça fera un segfault. Mais en tous cas ça n'affichera pas 0x0a0a0aàa)<br>Alors que pourtant a est bien un B tout ce qu'il y a de plus normal, qui n'a jamais été traffiqué, et qui contient 0x0a0a0a0a comme champ "a".</p><p>Un static_cast, au moins, t'afficherait la bonne valeur dans ces conditions.</p><p>Et si tu essayes, puisque c'est ce que tu veux faire, d'appeler une méthode de ton "a" qui est en réalité un B, après avoir fait un reinterpret_cast, là, la sanction est claire : segfault.<br>Parce que pour savoir quelle méthode appliquée, il doit consulter le pointeur de type dynamique. Et que ce pointeur contient n'importe quoi.</p><p>Avec un static_cast, au moins, le segfault ne serait intervenu que si ta variable n'est pas un vrai "B".<br>Avec un dynamic_cast, tu n'as pas de segfault du tout, puisque tu peux vérifier avant d'appeler la méthode que le dynamic_cast retourne bien un pointeur valide.</p><br><br><p>Bilan : mon exemple est exactement similaire au tien. Et pourtant, je fais facilement faire n'importe quoi et se mélanger les pinceaux au compilateur entre les structures, même sans avoir rien fait de bizarre (hormis le reinterpret_cast ou le coup de l'union). B hérite de A. Je range dans une variable de type A* un B*. Et si j'essaye d'accéder aux champs du B rangé dans cette variable, ou d'appeler des méthodes de ce B, j'obtiens au mieux n'importe quoi, au pire des segfault.</p><p>Là, je suis arrivé à ça, parce que j'ai mis une méthode virtuelle (même si je ne l'utilise jamais ; elle n'est pas concernée par le problème) dans B. <br>Mais encore une fois, je ne suis pas assez calé en C++ pour t'affirmer "à part si tu utilises des méthodes virtuelles, tu es sûr que ça marche". A mon avis la norme C++ ne garantit absolument rien sur l'organisation interne des objets (parce que si elle garantissait quelque chose, elle serait obligée de préciser "sauf existence de méthodes virtuelles", ce qui serait très pourri. Donc à mon avis, elle doit dire "vous ne pouvez pas faire d'hypothèses"<strong></strong>)<br>Et puis, il y a peut-être d'autres situations qui conduisent au même résultat. Tu n'avais pas pensé à celle-là (moi non plus dans un premier temps). Qui sait à quelle autre on ne pense pas.</p><p>Bref : ne fais pas ça.</p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div><div class="tid_post tid_ tid_read" id="tid_forumPost_6">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="ayalti" style="background-color: rgb(204,171,82); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 21 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_36044 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/36044/1" tid_id="36044">ayalti</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p>Et j'ajoute encore : dans cette situation un static_cast ferait des conversions, certes. Mais sauf si tu as prévu explicitement un opérateur de conversion, ces conversions se borneraient à décaler des index. <br>A dire que quand on utilise un B* comme si c'était un A*, on va chercher les champs 4 octets plus loin que quand on l'utilise en tant que B*. Ça ne coûte rien du tout. Et quand je dis rien, je veux dire "rien", pas "très peu". Sur les processeurs x86, et probablement sur tous les autres processeurs connus du moment, la conversion ne consiste que à changer des</p><pre>MOVL 0x0A0A0A0A, 0(%eax)</pre><p>en</p><pre>MOVL 0x0A0A0A0A, 4(%eax)</pre><p>Ce qui est EXACTEMENT la même chose en terme de calcul. La même instruction, les mêmes circuits du CPU utilisés, etc.</p><p>Sauf si tu compile pour un PIC ou un Atmel ou je ne sais quoi du genre (auquel cas tu ne ferais certainement pas du C++ de toutes façons), c'est totalement gratuit.</p><p>La seule différence, c'est que ça marche.</p><p>Un dynamic_cast coûterait un poil plus cher, parce qu'il irait à chaque fois vérifier le pointeur de classe dynamique. Mais au final, c'est une vérification que tu fais déjà certaineement à la main de toutes façons (tu vérifies bien un truc pour décider que ce A là, c'est un B, et que tu vas donc appeler une méthode B dessus). Donc pourquoi ne pas le laisser faire ça à ta place ?</p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div><div class="tid_post tid_ tid_read" id="tid_forumPost_7">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="Spirou003" style="background-color: rgb(84,82,204); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 21 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_26161 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/26161/1" tid_id="26161">Spirou003</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p><cite>Un dynamic_cast coûterait un poil plus cher, parce qu'il irait à chaque fois vérifier le pointeur de classe dynamique. Mais au final, c'est une vérification que tu fais déjà certaineement à la main de toutes façons (tu vérifies bien un truc pour décider que ce A là, c'est un B, et que tu vas donc appeler une méthode B dessus). Donc pourquoi ne pas le laisser faire ça à ta place ?</cite><br>Parce que je ne pensais pas qu'un "bête transtypage" de A* vers B* pouvait poser tant de problèmes s'il n'était pas fait avec static_cast ou dynamic_cast. Et surtout, je ne pensais pas que c'était le cas avec des exemples aussi simples.</p><p><cite>A mon avis la norme C++ ne garantit absolument rien sur l'organisation interne des objets</cite><br>À mon avis, mais c'est que pûre spéculation, la seule garantie qu'on peut espérer serait que les pointeurs vers la classe dynamique soient placés avant tout ce qu'on écrit nous-même. Sinon je vois mal comment le retrouver facilement.</p><p>Mais du coup, reinterpret_cast est un opérateur qu'il faut absolument éviter, il pose trop de problèmes. Le compilateur devrait au minimum générer un "warning" à chaque utilisation de ce cast.</p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div><div class="tid_post tid_ tid_read" id="tid_forumPost_8">
    <div class="tid_header tid_bg1">
        <div class="tid_floatBox">
            <table class="tid_valign" style="width : 80px">
                <tbody>
                    <tr>
                        <td>
                            <div class="tid_twinoidAvatar" style="width:80px; max-height:80px; height:80px;">
                                <img src="..\..\..\..\gfx\avatars\img_defaultAvatar.png" title="ayalti" style="background-color: rgb(204,171,82); width: 80px;">
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="tid_date">
            Le 21 août 2014
        </div>
        <div class="tid_name">
            <a class="tid_user tid_user_36044 tid_userNoBg tid_userFriend tid_parsed" href="//twinoid.com/user/go/36044/1" tid_id="36044">ayalti</a>
        </div>
        <div class="tid_title">
            
        </div>
        <div class="tid_clearRight"></div>
    </div>
    <div class="tid_body tid_bg2">
        <div class="tid_arrow"></div>
        <div class="tid_originContent">
            <div class="tid_editorContent tid_parsed">
                <p><cite> Le compilateur devrait au minimum générer un "warning" à chaque utilisation de ce cast.</cite>Pourquoi ?<br>reinterpret_cast veut dire <em>"je sais ce que je fais, alors fous moi la paix et fais ce que je te dis"</em>. C'est exactement ce que fait le compilateur.</p><p>Le rôle des warning n'est pas de prévenir les gens qui n'auraient pas compris le langage que ce qu'ils font est un peu bizarre.<br>Il est de prévenir les gens qui ont compris le langage que, <em>"ok, votre truc veut dire qqc, et je vois comment le compiler. Mais je me demande si c'est vraiment ce que vous vouliez dire"</em><br>Exemple caricatural : une variable non initialisée.</p><p>Quelqu'un qui utilise un reinterpret_cast, c'est pas par erreur<br>(Et puis, ce serait bizarre un warning qui apparait à chaque fois qu'on utilise une caractéristique du langage. Un bon code ne devrait contenir aucun warning. Ça voudrait dire qu'on considère qu'un mot clé du langage... n'aurait pas du être dans le langage. Ça peut se débattre. Mais c'est pas le rôle des compilateurs. C'est le rôle des gens qui définissent les langages. A la rigueur c'et le rôle de la documentation de mettre en garde contre les reinterpret_cast. Mais le compilateur, du moment que quelqu'un qui est supposé avoir lu la doc décide de l'utiliser, c'est pas à lui de dire <em>"Ah ouais ? Un reinterpret_cast, carrément ? Vous n'avez peur de rien vous dites-voir !"</em>.</p><p>A la rigueur pour le coup de l'union, si le compilateur pouvait dire "warning : ce que vous faites revient à faire un reinterpret_cast sur deux classes différentes", ça pourrait être intéressant. Encore que, l'union c'est du C, et ça sert aussi à dire au compilateur : <em>"cherche pas à comprendre, c'est moi qui gère le typage sur ce coup là, et je te dis que là, c'est bien un B (par exemple parce que j'ai un premier champ "type" qui me dit quel membre de l'union je dois utiliser)"</em><br>Mais bon, de toutes façons, il faudrait encore qu'il soit capable de détecter le truc bizarre qu'on fait. Et comme c'est dynamiquement que l'erreur est commise (c'est dynamiquement qu'on décide d'utiliser un B* comme un A*), il peut difficilement le détecter</p><p>(Si tu voulais dire "juste mettre un warning pour les cas où on utilise reinterpret_cast sur des classes qui ne vont pas être compatibles à cause d'un virtual" : c'est pareil. De toutes façons, il ne sait pas détecter que c'est possible. S'il savait détecter que c'est possible, il n'y aurait pas eu besoin de reinterpret_cast !)</p>
            </div>
        </div>
        <div class="tid_clear"></div>
    </div>
</div>
                                    <div id="tid_forumReplyForm" style="display: none"></div>
                                </div>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</body>
</html>